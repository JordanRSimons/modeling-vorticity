# Introduction to the Problem

This notebook represents the first step in our analysis. Our goal in this project is to test an ocean model called Lagrangian Gradient Regression, which computes a measure of rotation in currents called vorticity from soley particle trajectory data (Harms et al. 2023). Before we can generate test particle trajectories, we need to initialize particles. With our curved simulated coastline, a simple grid is not sufficient for particle seeding: Instead, we want to seed the particles along contours of ocean depth. 

So you can understand where we are going, here is our final distribution of the particles' initial positions. For more plots, and the code for this plot, please see the next notebook (02_analysis_and_plotting.md).

**Seeding Diagram**
![Seeding Diagram](../images/seeding.png)

In this figure, the white represents a landmass, and the color scheme represents water depth in our idealized simulation. The 1200 red dots represent our seeded particles - note how they appear on top of black contours of equal water depth.

# Seeding Particles with Flexible Functions

We needed the Python code to seed particles to be flexible enough to allow quick testing of a variety of seeding schemes (specifically we want to minimize particles used and maximize model accuracy), so this process is coded as a pair of functions. Broadly, the first function generates contours of equal depth, and the second function outputs the desired number of test points distributed between the contours from the first function's output.

We will need the following libraries and a multidimensional NetCDF dataset containing information about our simulated coastline's water's depth and motion:

```python
import xarray as xr
import numpy as np
import zarr
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import matplotlib.animation as animation
import matplotlib.colors as colors
import cmasher
import pandas as pd
import cmocean
from scipy import stats
from scipy.ndimage import median_filter, uniform_filter

ds = xr.load_dataset('/Users/jordan/Documents/CICOES/data/cape_large_00.nc', decode_times = False)
```
## Function 1: getContours

```python
def getContours(ds, levels = False, ncont = False, bound = 10) :
```
This function takes four inputs, supporting two distinct methods of contour creation:
* ds: imported above, a dataset related to the simulated basin
* levels: an array of specified depths at which to make contours
* ncont: the number of contours to include (only used if levels=False)
* bound: the maximum depth to draw contours at

The output will be two arrays, X and Y. Each term of X is an array containing all the x positions of one of the requested contours. Y contains the corresponding y values.

If levels are not provided, they are generated at even spacing:

```python
    # determine contour levels, if needed
    if levels == False :

        # exclude the right endpoint
        # compute one more value than necesary so we can remove the left endpoint as well
        # we don't want particles seeded at a depth of 0
        levels = np.linspace(1, bound, ncont + 1, endpoint = True)
        levels = levels[1:]
```

The contours themselves are actually generated by creating a matplotlib plot object. The plot serves as a diagnostic tool as well, but I will not display it here.

```python
    # generate plotting grid based on the rho points (positional coordinates of a special form)
    x_rho = ds.x_rho[0,:].values 
    y_rho = ds.y_rho[:,0].values
    Xplot, Yplot = np.meshgrid(x_rho, y_rho)
    
    fig, ax = plt.subplots(figsize = (5.5,4), dpi = 170)

    # create depth contours based on ds
    # note that we are storing the contours for later use
    conts = ax.contour(Xplot, Yplot, ds['h'], levels = levels, colors = 'k')

    # boundary contour
    ax.contour(Xplot, Yplot, ds['h'], levels = [bound], colors = 'red', linestyles = 'dashed')

    # draws the land
    ax.pcolormesh(ds.x_psi, ds.y_psi, np.ma.masked_where(ds.mask_psi == 1, ds.mask_psi), cmap = 'gray')
    
    # axis and plot atributes
    ax.set_xlabel(r'$x$ (m)')
    ax.set_ylabel(r'$y$ (m)')
    
    ax.set_ylim(0,1200)
    ax.set_xlim(-1050,1050)
    ax.set_aspect("equal") # make a meter the same distance on each axis

    plt.title("Bathymatry Contours Output: {}".format(len(levels)))

    plt.show()
```

These stored contours can then be accessed to give the desired points. 

```python
    X = []; Y = []
    
    for i in range(0, len(levels)) :

        # take the ith level, 
        # then get an array of the x values and y values making up matplotlib contour objects
        xi = conts.allsegs[i][0].T[0]
        yi = conts.allsegs[i][0].T[1]
        

        X.append(xi)
        Y.append(yi)

    return X,Y
```

We now have points on contours, but there is no way yet to control over how many points get included on each contour. In a scienfific context, we want equal numbers of particles on each contour, spaced an even distance apart. 

## Function 2: getPoints

For simplicity, say we want 50 points spread across 5 contours (so 10 points per contour). You might think that we could just divide the x-axis evenly into 11 chunks, and place a seeded particle as close to each of the 10 dividing dividing lines as possible on each contour.

The problem with this implementation is that spacing particles evenly with respect to the x-axis is not the same as placing them evenly across the contour. Since the contours are curved, distances along them need to be computed differently. The getPoints function performs this computation.

```python
def getPoints(ds, X, Y, npart) :
```
The first three three inputs should be familiar: the dataset about the basin, and the two output arrays from the getContours function. The last input, npart, is simply the desired number of particles to be seeded. For the plot at the begining of the notebook, npart = 1200.

The funciton then outputs two arrays, xvals and yvals, which each have length npart and contain the x and y coordinates for the seeded points.

To place particles at even points along the contours, we will need the total length of each contour. The distance between any two points $(x_1, y_1)$ and $(x_2, y_2)$ can be approximated via the Pythagorean Theorem:

$D = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$

By adding up the distances between all of the many points that define contour object, we can get a total length, saved in this case as a cumulative sum:

```python
# empty lists for particle position coordinates
    xvals = []; yvals = []
    
    # loop through contours 
    for c in range(len(X)) :
    
        # remember, each term of X and Y is an array containing 
        # all generated x and y values for an entire contour
        xc = X[c]
        yc = Y[c]

        # this code generates an array of distances between particles
        # start at 0 because the first point is the start of the contour, a distance 0 along it
        # S is defined as a distance coordinate along the contour.
        deltaS = [0]

        # loop through all particles (minus the first one)
        for p in range(len(xc) - 1) :
            deltaS.append( round(np.sqrt( (xc[p+1] - xc[p])**2 + (yc[p+1] - yc[p])**2), 3) )


        # this generates a cumulitive sum array, where each entry is the value S at point i
        Scumsum = np.cumsum(deltaS)
```


With this cumulative sum, we can then derive an array of increasing distances from the left side of each contour, called Svals. The np.linspace command which derives Svals evenly divides the length of each contour (Scumsum[-1]) into npart/ncont + 1 parts. The total number of particles are divided between ncont contours, and the +1 allows us to remove edge values.

```python
        # the number of contours is the number of separate arrays of positions in the array X
        ncont = len(X)
        
        # exclude the right endpoint, compute one more value than necesary so we can remove the left endpoint as well.
        # we don't want a particle at S = 0 or S = Scumsum[-1] because it would be on the edge of the screen.
        Svals = np.linspace(0, round(Scumsum[-1]), int(npart/ncont + 1), endpoint = False)
        Svals = Svals[1:]

        # interpolate the x and y values at our evenly spaced Svals
        xvalsc = np.interp(Svals, Scumsum, xc)
        yvalsc = np.interp(Svals, Scumsum, yc)

        # add our new points to our masterlists that will be returned
        xvals = np.concatenate([xvals, xvalsc])
        yvals = np.concatenate([yvals, yvalsc])

    return xvals,yvals
```

The starting positions have been set, and we can now utilize the flow data contained in our dataset to produce test particle trajectory data to which LGR can be applied.

Particle seeding for any configuration we want can be acomplished easily:

```python
X,Y = getContours(ds, ncont = ncont)
pointLists = getPoints(ds, X, Y, npart = 1200) 
```

# Generating Particle Trajectories

The particle trajectories are generated using a vector field of current strengths originating from wind-driven waves. This earlier simulation  of these current strengths using the ocean model ROMS was done by my research mentor Dr. Torres and is not recorded here. The results of this simulation are stored in the netCDF dataset ds we have been using in this notebook.

With the stored vector field data, we compute Lagrangian velocities (aka velocities with respect to particles themselves) at all points in the simulated environment. The particles will then follow tracks in this environment.

```python
ds["ubar_lagrangian"] = ds["ubar"] + ds["ubar_stokes"]
ds["vbar_lagrangian"] = ds["vbar"] + ds["vbar_stokes"]
```

The Ocean Parcels code then requires a variety of parameters...

```python
# positions, distinct from the rho coordinates used above
x_psi,y_psi, = ds.x_psi, ds.y_psi
mesh = "flat"

velocities = {'U': 'ubar_lagrangian',
              'V': 'vbar_lagrangian'}

dimensions = {'U': {'lon': 'x_u', 'lat': 'y_u'},
              'V': {'lon': 'x_v', 'lat': 'y_v'}}

fieldset = FieldSet.from_xarray_dataset(ds, variables = velocities, dimensions = dimensions, mesh = mesh, 
                                        time_periodic = False,
                                        interp_method={
                                        "U": "freeslip",
                                        "V": "freeslip",
                                        },
                                       )
```

and then produces the trajectories, saving them into a .zarr file:

```python
xpoints = pointLists[0]
ypoints = pointLists[1]

# function to remove particles if they move onto land between timesteps
def CheckOutOfBounds(particle, fieldset, time):
    if particle.state == StatusCode.ErrorOutOfBounds:
        particle.delete()

### parcels code to output a .zarr file of advected particle trajectories

# feed in the above parameters
# define the x and y coordinates as longitude and latitude
pset = ParticleSet.from_list(fieldset = fieldset, pclass = JITParticle, time = ds.ocean_time.values, lon = xpoints, lat = ypoints)

# name output file
output_file = pset.ParticleFile(name = f"/Users/jordan/Documents/CICOES/data/posterData/1200p_{ncont}c_dt15", outputdt = timedelta(seconds = 30))

# use the standard advection kernel and our CheckOutOfBounds kernel above
kernels = AdvectionRK4 + pset.Kernel(CheckOutOfBounds)

# execute the advection over runtime with steps of size dt
pset.execute(kernels, runtime = timedelta(hours =  1), dt = timedelta(seconds = 15), output_file = output_file, verbose_progress = True)
```

These created files can then be used for further analysis and visualization. See the next notebook (02_analysis_and_plotting.md) for details.

# Appendix: Code for Seeding Diagram in Introduction

```python
fig, ax = plt.subplots(figsize = (14,6.5), dpi = 100, constrained_layout = True)

# color the map by depth contour
dep = ax.pcolormesh(Xrho, Yrho, ds['h'], vmin = 0, vmax = 20, cmap = cmocean.cm.haline_r, alpha = 0.5)

# plot contour lines
cs = ax.contour(Xrho, Yrho, ds['h'], levels = np.arange(1,20,2), colors = 'k')
ax.clabel(cs, np.arange(1,20,2))

# plot seeded points
ax.scatter(xvals, yvals, s = 8, c = 'red')

# draws the land
ax.pcolormesh(ds.x_psi, ds.y_psi, np.ma.masked_where(ds.mask_psi == 1, ds.mask_psi), 
              cmap = colors.ListedColormap(['#FAF6EB', '#ffffff00']))

ax.set_xlabel(r'$x$ (m)', size = 24)
ax.set_ylabel(r'$y$ (m)', size = 24)

ax.xaxis.set_tick_params(labelsize=24)
ax.yaxis.set_tick_params(labelsize=24)

ax.set_ylim(0,800)
ax.set_xlim(-1050,1050)
ax.set_aspect("equal")

# create the legend
cbar = fig.colorbar(dep, orientation = "vertical", fraction = 0.05, aspect = 20, shrink = 0.675, pad = 0.01) 
cbar.set_label(label='Depth (m)', size=28) 
cbar.ax.tick_params(labelsize = 24) 

plt.savefig('plots/poster_video/seeding_test.png')
plt.close(fig)
```

